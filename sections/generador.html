<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>QF PRO â€” Generador</title>
  <link rel="stylesheet" href="../css/styles.css"/>
</head>
<body>
<div class="app">
  <aside class="sidebar">
    <div class="brand"><strong>QF PRO</strong><br><span class="muted">Generador</span></div>
    <nav style="margin-top:12px">
      <a class="nav-item" href="../index.html">ğŸ·ï¸ Inicio</a>
      <a class="nav-item" href="atencion.html">ğŸ§‘â€âš•ï¸ AtenciÃ³n farmacÃ©utica</a>
      <a class="nav-item active" href="generador.html">ğŸ“ Generador de texto</a>
      <a class="nav-item" href="vademecum.html">ğŸ’Š VademÃ©cum</a>
      <a class="nav-item" href="material.html">ğŸ“š Material de consulta</a>
      <a class="nav-item" href="herramientas.html">ğŸ§° Herramientas</a>
      <a class="nav-item" href="proa.html">ğŸ§ª PROA</a>
      <a class="nav-item" href="plantas.html">ğŸŒ¿ Plantas medicinales</a>
      <a class="nav-item" href="protocolos.html">ğŸ“‘ Orientaciones tÃ©cnicas</a>
      <a class="nav-item" href="config.html">âš™ï¸ ConfiguraciÃ³n</a>
    </nav>
  </aside>

  <div class="main">
    <div id="header"></div>
    <main class="container">
      <div class="row" style="gap:8px">
        <label>Ficha:
          <select id="sel-ficha"></select>
        </label>
        <button id="btn-compilar" class="btn">Compilar</button>
      </div>
      <div class="card" style="margin-top:10px">
        <textarea id="texto" rows="18" style="width:100%" placeholder="Texto listo para ficha clÃ­nicaâ€¦"></textarea>
      </div>
    </main>
  </div>
</div>

<script type="module">
  import { mountHeader } from "../js/header.js";
  import { FichasStore } from "../js/fichasStore.js";
  import { evaluarInteracciones } from "../js/rulesEngine.js";
  import { loadAll as loadMeds } from "../js/medStore.js";

  mountHeader();

  const $sel = document.getElementById("sel-ficha");
  const $txt = document.getElementById("texto");
  const $btn = document.getElementById("btn-compilar");

  const dataState = {
    interacciones: null,
    criterios: null,
    ppiMap: new Map(),
    medsDB: null,
  };

  const dataReady = loadCatalogos();

  async function loadCatalogos() {
    await Promise.all([loadInteracciones(), loadCriterios(), loadMedsDB()]);
  }

  async function loadInteracciones() {
    try {
      const data = await fetch("../data/interacciones.json").then((r) => r.json());
      dataState.interacciones = data;
    } catch (err) {
      console.error("âŒ No fue posible cargar interacciones.json", err);
      dataState.interacciones = null;
    }
  }

  async function loadCriterios() {
    try {
      const data = await fetch("../data/criterios.json").then((r) => r.json());
      dataState.criterios = data;
      dataState.ppiMap = buildPpiMap(data);
    } catch (err) {
      console.error("âŒ No fue posible cargar criterios.json", err);
      dataState.criterios = null;
      dataState.ppiMap = new Map();
    }
  }

    async function loadMedsDB() {
    try {
      dataState.medsDB = await loadMeds();
    } catch (err) {
      console.error("âŒ No fue posible cargar medicamentos.json", err);
      dataState.medsDB = null;
    }
  }

  function loadFichas() {
    const listado = FichasStore.list();
    $sel.innerHTML = `<option value="">â€” Selecciona â€”</option>` + listado.map((f) => `<option value="${f.id}">${f.id}</option>`).join("");
    const hash = (location.hash || "").replace("#", "").toUpperCase();
    if (hash) $sel.value = hash;
  }

  const mapAnt = (x) => x;

  const normalizeBaseKey = (txt = "") =>
    txt
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "")
      .toUpperCase()
      .trim();

  const buildCriterioKey = (baseKey = "", texto = "") => {
    const safeBase = normalizeBaseKey(baseKey);
    const safeTxt = normalizeBaseKey(texto || baseKey);
    if (!safeBase && !safeTxt) return "";
    return `${safeBase}__${safeTxt}`;
  };

    const normalizeTagLabel = (tag = "") =>
    tag
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "")
      .toUpperCase()
      .trim();

  const collectTagsForMed = (med = {}) => {
    const direct = med.tags || med.etiquetas || med.raw?.tags;
    if (Array.isArray(direct) && direct.length) return direct;
    const skuInfo = dataState.medsDB?.skuById?.[med.sku] || dataState.medsDB?.meds?.[med.sku];
    const skuTags = skuInfo?.tags || skuInfo?.etiquetas || skuInfo?.raw?.tags;
    if (Array.isArray(skuTags)) return skuTags;
    return [];
  };

  const buildFamiliaKeys = (med = {}) =>
    collectTagsForMed(med)
      .slice(1)
      .map((et) => normalizeTagLabel(et))
      .filter(Boolean);

  const lineDiagnosticos = (f) => {
    const antecedentes = f?.anamnesis?.antecedentes || [];
    const diag = antecedentes.length ? antecedentes.map(mapAnt).join(", ") : "sin registro";
    return `- Usuario con diagnÃ³sticos de ${diag}.`;
  };

  const lineAntecedentesRelevantes = (f) => {
    const flags = f?.anamnesis?.flags || {};
    const lista = [];
    if (flags.antIAMACV) lista.push("IAM/ACV");
    if (flags.erc) lista.push("ERC");
    if (!lista.length) return "";
    return `- Usuario con antecedentes de ${lista.join(", ")}.`;
  };

  const linePDC = (f) => {
    const pdc = (f?.anamnesis?.adherencia?.pdc || "sin registro").trim();
    return `- Adherencia segÃºn PDC: ${pdc}.`;
  };

  function buildAntecedentes(f) {
    const lines = ["1. ANTECEDENTES", "", lineDiagnosticos(f)];
    const relevantes = lineAntecedentesRelevantes(f);
    if (relevantes) lines.push(relevantes);
    lines.push(linePDC(f));
    return lines.filter(Boolean).join("\n");
  }

  const formatearCantidad = (item) => {
    const nombreUpper = (item.nombre || "").toUpperCase();
    const yaPos = /\b(CADA|SOS)\b/.test(nombreUpper);
    if (yaPos) return "";
    if ((item.forma || "").toLowerCase() === "insulina") {
      return ` ${item.uiAm || 0} UI AM - ${item.uiPm || 0} UI PM`;
    }
    if (item.cantidad) return ` ${item.cantidad} ${item.unidad || ""}`;
    return "";
  };

    const limpiarPosologia = (item) => {
    let posologia = (item.posologia || "").trim();
    if (!posologia) return "";
    const unidad = (item.unidad || "").toUpperCase();
    if (unidad === "UNIDAD(ES)") {
      posologia = posologia.replace(/^\s*(C[ÃA]PSULAS?|C[ÃA]PSULA|COMPRIMIDOS?|TABLETAS?|UNIDADES?)\s+/i, "");
    }
    return posologia.replace(/\s+/g, " ").trim();
  };

  const formatearMed = (item) => {
    const nombre = (item.nombre || item.base || "").trim();
    const cantidad = formatearCantidad(item);
    const posologiaTxt = limpiarPosologia(item);
    const posologia = posologiaTxt ? ` ${posologiaTxt}` : "";
    return `${nombre}${cantidad}${posologia}`.trim();
  };

  const formatFecha = (fechaISO) => {
    if (!fechaISO) return "sin registro";
    const d = new Date(fechaISO);
    if (Number.isNaN(d.getTime())) return fechaISO;
    return new Intl.DateTimeFormat("es-CL", { day: "2-digit", month: "2-digit", year: "numeric" }).format(d);
  };

  const describeReceta = (label, receta = {}) => {
    const meds = (receta.meds || []).map(formatearMed).filter(Boolean);
    if (!meds.length) return "";
    const fecha = formatFecha(receta.fechaISO || new Date().toISOString().slice(0, 10));
    const meses = receta.meses || 1;
    const mesesTexto = `${meses} ${meses === 1 ? "mes" : "meses"}`;
    const header = `- Receta vigente en ${label}, emitida ${fecha} por ${mesesTexto}:`;
    const cuerpo = meds.map((m) => `Â· ${m}`).join("\n");
    return `${header}\n${cuerpo}`;
  };

  function buildMedicacion(f) {
    const bloques = [];
    (f.meds?.apsRecetas || []).forEach((rec) => {
      const bloque = describeReceta("APS", rec);
      if (bloque) bloques.push(bloque);
    });
    (f.meds?.secRecetas || []).forEach((rec) => {
      const origen = rec.origenLabel || rec.origenEstablecimiento || "A2S";
      const bloque = describeReceta(origen, rec);
      if (bloque) bloques.push(bloque);
    });
    if (!bloques.length) return "";
    return ["2. MEDICACION", "", bloques.join("\n\n")].join("\n");
  }

  function getAllMeds(ficha) {
    if (!ficha) return [];
    const meds = [];
    const pushRec = (arr = [], origen, sourceKey) => {
      (arr || []).forEach((rec) => {
        (rec.meds || []).forEach((m) => {
          meds.push({
            ...m,
            base: (m.base || m.nombre || "").toUpperCase(),
            nombre: m.nombre || "",
            origen,
            sourceKey,
            recetaId: rec.id,
            tags: collectTagsForMed(m),
          });
        });
      });
    };
    pushRec(ficha.meds?.apsRecetas, "APS", "apsRecetas");
    pushRec(ficha.meds?.secRecetas, "A2S", "secRecetas");
    (ficha.meds?.extra || []).forEach((m) => {
      meds.push({
        ...m,
        base: (m.base || "").toUpperCase(),
        nombre: m.nombre || "",
        origen: "Extrasistema",
        sourceKey: "extra",
        tags: collectTagsForMed(m),
      });
    });
    (ficha.meds?.automed || []).forEach((m) => {
      const texto = (m.nombre || m.texto || "").trim();
      meds.push({
        ...m,
        base: (m.base || texto.split(/\s+/)[0] || "").toUpperCase(),
        nombre: texto || m.base || "",
        origen: "AutomedicaciÃ³n",
        sourceKey: "automed",
        tags: collectTagsForMed(m),
      });
    });
    return meds;
  }

  function detectarDuplicados(meds) {
    const mapaBase = new Map();
    const mapaFamilia = new Map();

    const addToMap = (mapa, clave, med) => {
      if (!clave) return;
      if (!mapa.has(clave)) mapa.set(clave, []);
      mapa.get(clave).push(med);
    };

    meds.forEach((med) => {
      const base = (med.base || "").toUpperCase();
      addToMap(mapaBase, base, med);
      buildFamiliaKeys(med).forEach((fam) => addToMap(mapaFamilia, fam, med));
    });

    const buildEntry = (label, arr, tipo = "base") => {
      if (arr.length < 2) return null;
      const claves = new Set(arr.map((m) => `${m.sourceKey || ""}:${m.recetaId || m.id || ""}`));
      if (claves.size <= 1) return null;
      if (tipo === "familia") {
        const bases = new Set(arr.map((m) => m.base || m.nombre || ""));
        if (bases.size <= 1) return null;
      }
      const origenes = Array.from(new Set(arr.map((m) => m.origen || "Receta")));
      return { base: label, origenes, tipo };
    };

    const duplicados = [];
    mapaBase.forEach((arr, base) => {
      const entry = buildEntry(base, arr, "base");
      if (entry) duplicados.push(entry);
    });
    mapaFamilia.forEach((arr, familia) => {
      const entry = buildEntry(`FAMILIA: ${familia}`, arr, "familia");
      if (entry) duplicados.push(entry);
    });
    return duplicados;
  }

  function buildBaseLabelMap(meds = []) {
    const map = new Map();
    meds.forEach((med) => {
      const baseKey = normalizeBaseKey(med.base || med.nombre || "");
      if (!baseKey) return;
      const etiqueta = (med.base || med.nombre || "").replace(/\s+/g, " ").trim().toUpperCase();
      if (!map.has(baseKey)) map.set(baseKey, etiqueta);
    });
    return map;
  }

  function buildInteraccionesList(meds) {
    if (!dataState.interacciones) return [];
    const bases = Array.from(new Set(meds.map((m) => (m.base || "").toUpperCase()).filter(Boolean)));
    if (bases.length < 2) return [];
    const baseLabels = buildBaseLabelMap(meds);
    const inter = evaluarInteracciones({ meds: bases, interacciones: dataState.interacciones }) || [];
    return inter
      .map((ix) => {
        const encontrados = ix.grupos
          ?.flatMap((g) => g.encontrados || [])
          .map((base) => baseLabels.get(normalizeBaseKey(base)) || base)
          .filter(Boolean) || [];
        const etiqueta = Array.from(new Set(encontrados)).map((txt) => txt.replace(/\s+/g, " ").trim()).join("+");
        const texto = ix.comentario || ix.descripcion || "InteracciÃ³n detectada.";
        const textoLimpio = etiqueta ? texto.replace(/^[^,]+,\s*/, "") : texto;
        return etiqueta ? `${etiqueta}, ${textoLimpio}` : texto;
      })
      .filter(Boolean)
      .sort((a, b) => a.localeCompare(b, "es", { sensitivity: "base" }));
  }

  function buildPpiMap(raw) {
    const map = new Map();
    if (!raw) return map;

    const addPool = (arr = [], tipo = "ppi") => {
      arr.forEach((item) => {
        const texto = (item.texto || item.descripcion || "").trim();
        const recomendacion = (item["recomendaciÃ³n"] || item.recomendacion || "").trim();
        const criterio = (item.criterio || item.criterios || "").trim();
        if (!texto) return;

        const bases = Array.from(
          new Set(
            [item.base, ...(item.medicamentos || [])]
              .map((b) => normalizeBaseKey(b))
              .filter(Boolean)
          )
        );

        bases.forEach((baseKey) => {
          const entry = { baseKey, texto, tipo, recomendacion, criterio, key: buildCriterioKey(baseKey, texto) };
          if (!map.has(baseKey)) map.set(baseKey, []);
          map.get(baseKey).push(entry);
        });
      });
    };

    addPool(Array.isArray(raw.ppi) ? raw.ppi : [], "ppi");
    addPool(Array.isArray(raw.start) ? raw.start : [], "start");
    return map;
  }

  function buildPpiList(ficha, meds) {
    if (!ficha.age65) return { aplica: false, hallazgos: [] };
    const baseLabels = buildBaseLabelMap(meds);
    const presentes = new Set(meds.map((m) => normalizeBaseKey(m.base || m.nombre || "")).filter(Boolean));
    const prefs = ficha?.ppiChecks || {};
    const vistos = new Set();
    const hallazgos = [];
    presentes.forEach((clave) => {
      const criterios = (dataState.ppiMap.get(clave) || []).filter((item) => item.tipo === "ppi");
      if (!criterios.length) return;
      const etiqueta = baseLabels.get(clave) || clave;
      criterios.forEach((item) => {
        const incluir = prefs[item.key] !== false;
        if (!incluir || vistos.has(item.key)) return;
        vistos.add(item.key);
        hallazgos.push(`${etiqueta}: ${item.texto}`);
      });
    });
    hallazgos.sort((a, b) => a.localeCompare(b, "es", { sensitivity: "base" }));
    return { aplica: true, hallazgos };
  }

   const normalizeRamEntry = (entry = {}) => {
    const efectos = Array.isArray(entry.efectos)
      ? entry.efectos
      : entry.efecto
      ? [{ nombre: entry.efecto, prevalencia: entry.prevalencia || "" }]
      : [];
    return { ...entry, efectos };
  };

  const parsePrevalencia = (prev = "") => {
    const clean = String(prev).replace(/,/g, ".");
    const match = clean.match(/([0-9]*\.?[0-9]+)/);
    if (!match) return null;
    const val = parseFloat(match[1]);
    return Number.isNaN(val) ? null : val;
  };

  const categorizePrevalencia = (prev = "") => {
    const val = parsePrevalencia(prev);
    if (val === null) return null;
    if (val >= 1) return "comunes";
    if (val >= 0.1) return "raros";
    return "muy raros";
  };

  const resumenCategoriaRam = (efectos = []) => {
    const prioridad = { comunes: 3, raros: 2, "muy raros": 1 };
    let mejor = null;
    efectos.forEach((ef) => {
      const cat = categorizePrevalencia(ef.prevalencia);
      if (!cat) return;
      if (!mejor || prioridad[cat] > prioridad[mejor]) mejor = cat;
    });
    return mejor;
  };
 
  function buildErroresList(f) {
    const arr = f?.meds?.errores || [];
    return arr
      .map((err) => {
        const etapa = err.etapa ? `${err.etapa}: ` : "";
        const baseDesc = err.desc || "Revisar";
        const med = err.med && !baseDesc.toUpperCase().includes(err.med.toUpperCase()) ? ` (${err.med})` : "";
        return `- ${etapa}${baseDesc}${med}`;
      })
      .filter(Boolean);
  }

    const buildRamLines = (f) => {
    const eventos = (f?.eventosAdversos || []).map(normalizeRamEntry);
    const lines = [];
    eventos.forEach((ev) => {
      const efectos = Array.isArray(ev.efectos) ? ev.efectos.filter((ef) => ef?.nombre) : [];
      if (!efectos.length) return;
      const sintomas = efectos.map((ef) => ef.nombre).filter(Boolean);
      if (!sintomas.length) return;
      const sintomasTxt = sintomas.join(", ");
      const detalles = efectos
        .map((ef) => `${ef.nombre}${ef.prevalencia ? ` (${ef.prevalencia})` : ""}`)
        .join(", ");
      const categoria = resumenCategoriaRam(efectos);
      const catTxt = categoria ? ` ${categoria}` : "";
      lines.push(
        `- Usuario presenta ${sintomasTxt} a uso de ${ev.medNombre || "medicamento"}. La prevalencia de estos efectos adversos son${catTxt}: ${detalles}. Dejo constancia de notificaciÃ³n a plataforma SVI, referencia _____.`
      );
    });
    return lines;
  };

  function buildPRM(f) {
    const meds = getAllMeds(f);
    const duplicidades = detectarDuplicados(meds).map((dup) => {
      const etiqueta = (dup.base || "").trim();
      const origenes = dup.origenes?.length ? ` (${dup.origenes.join(", ")})` : "";
      return `- Se identifica duplicidad de ${etiqueta}${origenes}.`;
    });
    const interacciones = buildInteraccionesList(meds).map((txt) => `- ${txt}`);
    const ppi = buildPpiList(f, meds);
    const errores = buildErroresList(f);
    const tieneSecExtra = meds.some((m) => m.origen === "A2S" || m.origen === "Extrasistema");

    const lines = ["3. PROBLEMAS RELACIONADOS A MEDICAMENTOS", "", "3.1 DISCREPANCIAS"];
    if (!duplicidades.length) {
      if (!tieneSecExtra) {
        lines.push("No se encuentran recetas vigentes en nivel secundario o extra-sistema.");
      } else {
        lines.push("No se identifican discrepancias.");
      }
    } else {
      lines.push(...duplicidades);
    }

    lines.push("", "3.2 INTERACCIONES");
    if (meds.length <= 1) {
      lines.push("No aplica.");
    } else if (!interacciones.length) {
      lines.push("No se identifican interacciones de relevancia clÃ­nica.");
    } else {
      lines.push(...interacciones);
    }

    lines.push("", "3.3 CRITERIOS PPI");
    if (!ppi.aplica) {
      lines.push("No aplica (menor de 65 aÃ±os).");
    } else if (!ppi.hallazgos.length) {
      lines.push("No se identifican prescripciones potencialmente inapropiadas.");
    } else {
      lines.push(...ppi.hallazgos.map((txt) => `- ${txt}`));
    }

    lines.push("", "3.4 ERRORES DE MEDICACIÃ“N");
    if (!errores.length) {
      lines.push("No se identifican errores de medicaciÃ³n.");
    } else {
      lines.push(...errores);
    }

    const ram = buildRamLines(f);
    lines.push("", "3.5 REACCIONES ADVERSAS A MEDICAMENTOS");
    if (!ram.length) {
      lines.push("No se registran reacciones adversas a medicamentos.");
    } else {
      lines.push(...ram);
    }

    return lines.join("\n");
  }

  function buildIndicaciones(f) {
    const indicaciones = Array.isArray(f.indicaciones) ? f.indicaciones.map((txt) => (txt || "").trim()).filter(Boolean) : [];
    const lines = ["4. INDICACIONES", ""];
    if (indicaciones.length) {
      indicaciones.forEach((txt) => lines.push(`- ${txt}`));
    }
    return lines.join("\n");
  }

  function compilarFicha(f) {
    const bloques = [buildAntecedentes(f), buildMedicacion(f), buildPRM(f), buildIndicaciones(f)]
      .filter((txt) => typeof txt === "string" && txt.trim().length)
      .join("\n\n");
    return bloques;
  }

  $btn.onclick = async () => {
    const id = $sel.value;
    if (!id) return;
    const ficha = FichasStore.get(id);
    if (!ficha) return;
    await dataReady;
    $txt.value = compilarFicha(ficha);
  };

  loadFichas();
</script>
</body>
</html>